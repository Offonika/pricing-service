# Технический дизайн: сопоставление номенклатуры с ценами конкурентов (FTP)

## 1. Источники данных
- **Конкуренты (FTP):** `competitor_ftp_record`  
  Поля: `source`, `file_date`, `sku`, `name`, `link`, `price_opt`, `price_roz`, `in_stock`, `amount`, `observed_at (MSK)`.
- **Наша номенклатура (TopControl):** `tovar`  
  Поля для матчинга:  
  - точные идентификаторы: `articul`, `kod_infsys`, `kod_infsys1`;  
  - описательные: `naim`, `naim_long`;  
  - производитель: `id_proizvod`;  
  - ключи: `id`, `id_tovar` (используем как product_id).
- **Остатки:** `ostatki` (по `id_tovar`) — для обогащения витрин, не участвуют в матчинге.

## 2. Целевая запись
- Таблица `competitor_price` (или отдельная витрина, если решим не смешивать):  
  - `product_id` (наш товар)  
  - `competitor_id` (по `source`)  
  - `price` (берём `price_roz`, fallback `price_opt`)  
  - `in_stock` (из `in_stock` / `amount > 0`)  
  - `collected_at` (`observed_at`)  
  - доп. лог: откуда пришло (file_date, filename, raw_row_id).
- Журнал матчинга: считанные строки, ошибки/пропуски, дубль-матчи.

## 3. Правила сопоставления (по приоритету)
1) **Точное совпадение SKU:**  
   - Нормализуем `competitor_ftp_record.sku` и `tovar.articul`: trim, нижний регистр, убираем пробелы/табуляции, заменяем `·`, `–` на `-`.  
   - Если 1:1 — матч.  
   - Если несколько товаров → флаг «мульти-матч», в лог, не пишем в итоговую таблицу без ручного разрешения.
2) **Альтернативные коды:**  
   - Сравниваем с `kod_infsys` и `kod_infsys1` (та же нормализация).  
   - Аналогично, разрешаем только 1:1.
3) **(Опционально, второй этап) Название + производитель:**  
   - Требуем совпадение производителя (`id_proizvod` ↔ бренд из названия конкурента, если сможем маппить бренды).  
   - Fuzzy/contains по `naim/naim_long` vs `name`, с белыми/чёрными списками токенов.  
   - Включается только после тестов, отдельным флагом.
4) **Ручные оверрайды:**  
   - Таблица `product_match_override(product_id, competitor_source, sku, approved_by, comment)` приоритетнее любых правил.

## 4. Поток обработки
1) Берём новые записи из `competitor_ftp_record` за последние N дней или по `file_date` новых файлов.  
2) Для каждой строки:
   - применяем ручной оверрайд (если есть);  
   - пробуем правило (1) артикула; иначе (2) альтернативные коды; опционально (3) название/бренд;  
   - при успехе — апсерт в `competitor_price` (по `product_id`, `competitor_id`, `collected_at`), запоминаем `raw_row_id`;  
   - при неуспехе — пишем в лог «unmatched» с причиной;  
   - при множественном совпадении — в лог «ambiguous», не записываем.
3) Собираем статистику: найдено / нет / ambiguous по источникам и датам.

## 5. Ручные правки и контроль качества
- Отчёт для аналитика: unmatched по источникам, топ SKU без матча, ambiguous.
- Возможность добавить override и повторно прогнать матчинг за интервал.
- Метрики: доля матчей по файлу/источнику, время выполнения, количество дублей.

## 6. Ограничения и допущения
- LLM/ИИ не используем на первом этапе: делаем быстрый точный матч по артикулам/кодам.  
  Fuzzy по названиям — только после пилота и с метриками качества.
- Источник бренда из TopControl — `id_proизовod`. Если потребуется брендовое сравнение, заведём словарь `id_proизвод → brand_name` и парсер бренда из `name` конкурента.
- Поле `observed_at` считаем истинным временем наблюдения; используем его в `collected_at` для `competitor_price`.

## 7. План работ
1) (Док) Зафиксировать правила нормализации и ключи полей — **готово в этом документе**.  
2) (Код) Реализовать матчинг по артикулам/альт.кодам + overrides, запись в `competitor_price`.  
3) (Код) Добавить отчёт/лог unmatched и ambiguous, CLI/таску на прогон за последние файлы.  
4) (Доки) Обновить `README.md`/`docs/architecture.md` с описанием потока матчинга.  
5) (Опционально) Добавить fuzzy по названиям и брендам с флагом.

